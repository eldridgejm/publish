"""
publish
=======

A script to build and publish artifacts.

Terminology
-----------

An **artifact** is a file â€” usually one generated by code.

A **publication** is a coherent group of zero or more artifacts and their
metadata. A publication is defined in a `publish.yaml` file.

A publication may or may not belong to a **collection**. A collection is
defined in a `collection.yaml` file. It describes the schema to which all
publications in the collection must adhere.

An example of a collection is that of all *homeworks*. An example of a
publication is an individual *homework* within the collection. And an example
of an artifact is the pdf of the homework's solutions.

"""

from collections import deque
import pathlib
import textwrap
import typing
import yaml

import yamale


COLLECTION_FILE = "collection.yaml"
PUBLICATION_FILE = "publish.yaml"


class Error(Exception):
    """A generic error."""


class SchemaError(Exception):
    """A malformed configuration file."""

class Artifact(typing.NamedTuple):
    key: str
    workdir: pathlib.Path
    publication: "Publication"
    file: str
    recipe: str = None
    released: str = None


class Publication(typing.NamedTuple):
    key: str
    path: pathlib.Path
    collection: "Collection"
    metadata: typing.Mapping[str, typing.Any]
    artifacts: typing.Mapping[str, Artifact]


class Collection(typing.NamedTuple):
    key: str
    universe: "Universe"
    schema: str
    path: pathlib.Path
    publications: typing.Mapping[str, Publication]


class Universe(typing.NamedTuple):
    root: pathlib.Path
    collections: typing.Mapping[str, Collection]
    singletons: typing.Mapping[str, Publication]


def _load_collection_file(path, universe):
    """Read a Collection from a collection.yaml

    Parameters
    ----------
    path : pathlib.Path
        Path to the directory containing the collection.yaml file
    universe : Universe
        The universe that the collection will be added to.

    Returns
    -------
    The collection without publications.

    """
    key = str(path.relative_to(universe.root))

    with (path / COLLECTION_FILE).open() as fileobj:
        contents = yaml.load(fileobj, Loader=yaml.Loader)

    # validate collection file
    schema = yamale.make_schema(content="schema: str()")
    data = yamale.make_data(path / COLLECTION_FILE)
    try:
        yamale.validate(schema, data)
    except yamale.YamaleError as exc:
        raise SchemaError(f'{path} has invalid collection.yaml: {exc}')

    collection = Collection(
        key, universe=universe, schema=contents["schema"], path=path, publications={},
    )
    universe.collections[key] = collection

    return collection


def _load_artifact(key, definition, publication):
    artifact = Artifact(
        key=key,
        workdir=publication.path,
        publication=publication,
        **definition
    )
    publication.artifacts[key] = artifact
    return artifact


def _validate_publication_file(path, collection):

    class Artifacts(yamale.validators.Validator):
        tag = "artifacts"

        schema = textwrap.dedent(
            """
            
            """
            )

        def _is_valid(self, value):
            1/0
            return True

    validators = yamale.validators.DefaultValidators.copy()
    validators[Artifacts.tag] = Artifacts

    if collection is not None:
        schema = yamale.make_schema(content=collection.schema, validators=validators)
        contents = yamale.make_data(path / PUBLICATION_FILE)

        try:
            yamale.validate(schema, contents)
        except yamale.YamaleError:
            raise SchemaError(f'{path} does not match collection schema.')
    else:
        with (path / PUBLICATION_FILE).open() as fileobj:
            contents = yaml.load(fileobj, Loader=yaml.Loader)

        if 'artifacts' not in contents:
            raise SchemaError(f'{path} contains no artifacts.')

    return contents


def _load_publication_file(path, collection, universe):
    """Read a Publication from a publish.yaml.

    Parameters
    ----------
    path : pathlib.Path
        Path to the directory containing the publish.yaml file.
    collection : Collection
        The collection to add the publication to -- if any.
    universe : Universe
        The universe to add the publication to if it isn't in a collection.

    Returns
    -------
    Publication
        The publication with artifacts included.

    """

    if collection is not None:
        key = str(path.relative_to(collection.path))
    else:
        key = path.name

    contents = _validate_publication_file(path, collection)

    # metadata is everything that isn't an artifact
    metadata = contents.copy()
    try:
        del metadata["artifacts"]
    except KeyError:
        raise SchemaError(f'{path} contains no artifacts.')

    publication = Publication(
        key=key, path=path, collection=collection, metadata=metadata, artifacts={}
    )

    for artifact_key, artifact_definition in contents['artifacts'].items():
        _load_artifact(artifact_key, artifact_definition, publication)

    if collection is not None:
        collection.publications[key] = publication
    else:
        universe.singletons[key] = publication

    return publication


def discover(root: pathlib.Path):
    """Recursively find all publications in a directory."""

    universe = Universe(root=pathlib.Path(root), collections={}, singletons={})

    # we'll perform a BFS. Each node will be a (directory_path, collection)
    # pair we'll start with collection=None, signaling that we're under no
    # collection
    queue = deque([(root, None)])

    while queue:
        path, collection = queue.popleft()

        # check if we're entering a collection; if so, load it
        if (path / COLLECTION_FILE).exists():
            collection = _load_collection_file(path, universe)

        # check if this is a publication; if so, load it
        if (path / PUBLICATION_FILE).exists():
            _load_publication_file(path, collection, universe)

        # add all subdirectories to the queue
        for subpath in path.iterdir():
            if subpath.is_dir():
                queue.append([subpath, collection])

    return universe
